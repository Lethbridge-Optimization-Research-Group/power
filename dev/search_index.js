var documenterSearchIndex = {"docs":
[{"location":"api/#MPOPF-API-Reference","page":"API Reference","title":"MPOPF API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = MPOPF","category":"page"},{"location":"api/#Contents","page":"API Reference","title":"Contents","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Pages = [\"api.md\"]\nDepth = 2:2","category":"page"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api/#Module-Documentation","page":"API Reference","title":"Module Documentation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"MPOPF","category":"page"},{"location":"api/#MPOPF.MPOPF","page":"API Reference","title":"MPOPF.MPOPF","text":"MPOPF\n\nA module for Multi-Period Optimal Power Flow (MPOPF) modeling and optimization.\n\nThis module provides tools to create, optimize, and analyze MPOPF models using various formulations including AC, DC, and linearized versions.\n\nMain Features\n\nCreate MPOPF models using different factory types (AC, DC, Linear, etc.)\nOptimize MPOPF models\nHandle uncertainty in MPOPF models\nVisualize optimization results\n\n\n\n\n\n","category":"module"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [MPOPF]\nOrder   = [:type]","category":"page"},{"location":"api/#MPOPF.ACMPOPFModelFactory","page":"API Reference","title":"MPOPF.ACMPOPFModelFactory","text":"ACMPOPFModelFactory <: AbstractMPOPFModelFactory\n\nFactory for creating AC MPOPF models.\n\nFields\n\nfile_path::String: Path to the input data file.\noptimizer::Type: The optimizer to be used (e.g., Ipopt.Optimizer).\n\n\n\n\n\n","category":"type"},{"location":"api/#MPOPF.AbstractMPOPFModel","page":"API Reference","title":"MPOPF.AbstractMPOPFModel","text":"AbstractMPOPFModel\n\nAn abstract type serving as a base for all MPOPF model types.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPOPF.AbstractMPOPFModelFactory","page":"API Reference","title":"MPOPF.AbstractMPOPFModelFactory","text":"AbstractMPOPFModelFactory\n\nAn abstract type serving as a base for all MPOPF model factories.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPOPF.DCMPOPFModelFactory","page":"API Reference","title":"MPOPF.DCMPOPFModelFactory","text":"DCMPOPFModelFactory <: AbstractMPOPFModelFactory\n\nFactory for creating DC MPOPF models.\n\nFields\n\nfile_path::String: Path to the input data file.\noptimizer::Type: The optimizer to be used.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPOPF.LinMPOPFModelFactory","page":"API Reference","title":"MPOPF.LinMPOPFModelFactory","text":"LinMPOPFModelFactory <: AbstractMPOPFModelFactory\n\nFactory for creating linearized MPOPF models. If this factory is used then model_type needs to be specified in the create_model() function.\n\nFields\n\nfile_path::String: Path to the input data file.\noptimizer::Type: The optimizer to be used.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPOPF.MPOPFModel","page":"API Reference","title":"MPOPF.MPOPFModel","text":"MPOPFModel <: AbstractMPOPFModel\n\nRepresents a Multi-Period Optimal Power Flow model.\n\nFields\n\nmodel::JuMP.Model: The underlying JuMP model.\ndata::Dict: Dictionary containing the power system data.\ntime_periods::Int64: Number of time periods in the model.\nfactors::Vector{Float64}: Scaling factors for each time period.\nramping_cost::Int64: Cost associated with generator ramping.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPOPF.MPOPFModelUncertainty","page":"API Reference","title":"MPOPF.MPOPFModelUncertainty","text":"MPOPFModelUncertainty <: AbstractMPOPFModel\n\nRepresents a Multi-Period Optimal Power Flow model with uncertainty considerations.\n\nFields\n\nmodel::JuMP.Model: The underlying JuMP model.\ndata::Dict: Dictionary containing the power system data.\nscenarios::Dict: Dictionary of scenarios for uncertainty analysis.\ntime_periods::Int64: Number of time periods in the model.\nfactors::Vector{Float64}: Scaling factors for each time period.\nramping_cost::Int64: Cost associated with generator ramping.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPOPF.NewACMPOPFModelFactory","page":"API Reference","title":"MPOPF.NewACMPOPFModelFactory","text":"NewACMPOPFModelFactory <: AbstractMPOPFModelFactory\n\nFactory for creating new AC MPOPF models. This is only used when computing for feasibility\n\nFields\n\nfile_path::String: Path to the input data file.\noptimizer::Type: The optimizer to be used.\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [MPOPF]\nOrder   = [:function]","category":"page"},{"location":"api/#MPOPF.calculate_model_averages-Tuple{Dict{String, Dict{String, Dict{String, Float64}}}}","page":"API Reference","title":"MPOPF.calculate_model_averages","text":"calculate_model_averages(model_results::Dict{String, Dict{String, Dict{String, Float64}}})\n\nCalculate the average values for cost, verror, oerror and times for all models in the dictionary\n\nArguments\n\nmodel_results::Dict{String, Dict{String, Dict{String, Float64}}}: The dictionary of models to be analysed.\nThis model_results can be obtained by running the function load_and_compile_results.\n\nReturns\n\nDict{String, Dict{String, Float64}}: A dictionary that maps the model to a metric to a value\n\n\n\n\n\n","category":"method"},{"location":"api/#MPOPF.compute_and_save_feasibility","page":"API Reference","title":"MPOPF.compute_and_save_feasibility","text":"compute_and_save_feasibility(factory::Union{ACMPOPFModelFactory, DCMPOPFModelFactory, LinMPOPFModelFactory}, path::String, model_type=false)\n\nCompute the feasibility of a model and save the results to a specified path.\n\nArguments\n\nfactory::Union{ACMPOPFModelFactory, DCMPOPFModelFactory, LinMPOPFModelFactory}: The factory to create the model.\npath::String: The path where the results will be saved.\nmodel_type: The type of the model (optional, only needed for LinMPOPFModelFactory).\n\nReturns\n\nDict: A dictionary containing the results of the computation.\n\n\n\n\n\n","category":"function"},{"location":"api/#MPOPF.create_model","page":"API Reference","title":"MPOPF.create_model","text":"create_model(factory::AbstractMPOPFModelFactory, scenarios::Dict, time_periods::Int64=1, factors::Vector{Float64}=[1.0], ramping_cost::Int64=0)::MPOPFModelUncertainty\n\nCreate a Multi-Period Optimal Power Flow (MPOPF) model with uncertainty considerations.\n\nArguments\n\nfactory: The factory used to create the specific type of MPOPF model.\nscenarios: Dictionary of scenarios for uncertainty analysis.\ntime_periods: Number of time periods to consider in the model. Default is 1.\nfactors: Scaling factors for each time period. Default is [1.0].\nramping_cost: Cost associated with ramping generation up or down. Default is 0.\n\nReturns\n\nAn MPOPFModelUncertainty object representing the created MPOPF model with uncertainty.\n\n\n\n\n\n","category":"function"},{"location":"api/#MPOPF.create_model-Tuple{MPOPF.AbstractMPOPFModelFactory}","page":"API Reference","title":"MPOPF.create_model","text":"create_model(factory::AbstractMPOPFModelFactory; time_periods::Int64=1, factors::Vector{Float64}=[1.0], ramping_cost::Int64=0, model_type=undef)::MPOPFModel\n\nCreate a Multi-Period Optimal Power Flow (MPOPF) model. The factory passed in defines the type of model that will be returned\n\nIf LinMPOPFModelFactory is passed in as the factory then model_type needs to be specified.\n\nArguments\n\nfactory: The factory used to create the specific type of MPOPF model.\ntime_periods: Number of time periods to consider in the model. Default is 1.\nfactors: Scaling factors for each time period. Default is [1.0].\nramping_cost: Cost associated with ramping generation up or down. Default is 0.\nmodel_type: Optional parameter to specify a particular model type. Default is undef.\n\nReturns\n\nAn MPOPFModel object representing the created MPOPF model.\n\n\n\n\n\n","category":"method"},{"location":"api/#MPOPF.create_model_check_feasibility","page":"API Reference","title":"MPOPF.create_model_check_feasibility","text":"create_model_check_feasibility(factory::NewACMPOPFModelFactory, new_pg=false, new_qg=false, v=false, theta=false, time_periods::Int64=1, factors::Vector{Float64}=[1.0], ramping_cost::Int64=0)::MPOPFModel\n\nCreate a secondary model to assess the feasibility of a solution when comparing to the AC model.\n\nArguments\n\nfactory: The factory used to create the specific type of MPOPF model.\nnew_pg: Fixed values for active power generation, or false to skip fixing.\nnew_qg: Fixed values for reactive power generation, or false to skip fixing.\nv: Fixed values for bus voltages, or false to skip fixing.\ntheta: Fixed values for bus angles, or false to skip fixing.\ntime_periods: Number of time periods to consider in the model. Default is 1.\nfactors: Scaling factors for each time period. Default is [1.0].\nramping_cost: Cost associated with ramping generation up or down. Default is 0.\n\nReturns\n\nAn MPOPFModel object representing the created MPOPF model.\n\n\n\n\n\n","category":"function"},{"location":"api/#MPOPF.find_bound_violations-Tuple{JuMP.Model}","page":"API Reference","title":"MPOPF.find_bound_violations","text":"find_bound_violations(model::Model)\n\nCheck lower and upper bounds of all variables in a model, returns a dictionary of violations with additional mismatch data\n\nArguments\n\nmodel::Model: The model to be checked for vounds violations\n\nReturns\n\nDict{VariableRef, Tuple{Float64, Float64, Float64, Float64}}: A dictionary where each key \n\nis a variable ref and the value is a tuple of data.\n\n\n\n\n\n","category":"method"},{"location":"api/#MPOPF.find_infeasible_constraints-Tuple{JuMP.Model}","page":"API Reference","title":"MPOPF.find_infeasible_constraints","text":"find_infeasible_constraints(model::Model)\n\ncheck the feasibility of the constraints in a model, returns a dictionary of infeasible constraints\n\nArguments\n\nmodel::Model: The model to be checked for constraint violations\n\nReturns\n\n[]: An array of the infeasible constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#MPOPF.generate_load_scenarios-Tuple{Int64, Int64}","page":"API Reference","title":"MPOPF.generate_load_scenarios","text":"generate_load_scenarios(num_scenarios::Int, num_buses::Int)\n\nGenerate load scenarios for a given number of scenarios and buses.\n\nArguments\n\nnum_scenarios::Int: The number of scenarios to generate.\nnum_buses::Int: The number of buses in the case file.\n\nReturns\n\nDict{Int, Dict{Int, Float64}}: A dictionary where each key \n\nis a scenario number and the value is another dictionary  mapping bus numbers to load factors.\n\n\n\n\n\n","category":"method"},{"location":"api/#MPOPF.get_ref-Tuple{Dict{String, Any}}","page":"API Reference","title":"MPOPF.get_ref","text":"get_ref(data::Dict{String, Any})\n\nBuild and return a reference object from the given power system data dictionary.\n\nArguments\n\ndata: Dictionary containing the power system data for a given case file.\n\nReturns\n\nA reference object containing processed power system data.\n\n\n\n\n\n","category":"method"},{"location":"api/#MPOPF.load_and_compile_models-Tuple{String}","page":"API Reference","title":"MPOPF.load_and_compile_models","text":"load_and_compile_models(results_directory::String)\n\nLoad models (Contrary to load_and_compile_results) from a directory and compile them into a dictionary for further analysis. Example, getting the pg value from case14 AC: model_results[\"case14\"][\"AC\"].model[:pg].\n\nArguments\n\nresults_directory::String: The directory where the models are stored.\n\nReturns\n\nDict{String, Dict{String, Dict{String, Any}}}: A dictionary containing the data of the models.\n\n\n\n\n\n","category":"method"},{"location":"api/#MPOPF.load_and_compile_results","page":"API Reference","title":"MPOPF.load_and_compile_results","text":"load_and_compile_results(results_directory::String, save_to_file::Bool=false)\n\nLoad results from a directory and compile them into a dictionary for further analysis.\n\nArguments\n\nresults_directory::String: The directory where the results are stored. To get results run the function compute_and_save_feasibility.\nsave_to_file::Bool: Whether to save the generated results to a file (optional) (Not yet implemented).\n\nReturns\n\nDict{String, Dict{String, Dict{String, Float64}}}: A dictionary containing the results of the computation.\n\n\n\n\n\n","category":"function"},{"location":"api/#MPOPF.load_and_graph_results","page":"API Reference","title":"MPOPF.load_and_graph_results","text":"load_and_graph_results(results_directory::String, save_to_file::Bool=false)\n\nLoad results from a directory and generate graphs for feasibility, voltage magnitude error, voltage angle error, and computation times (times not complete).\n\nArguments\n\nresults_directory::String: The directory where the results are stored. To get results run the function compute_and_save_feasibility.\nsave_to_file::Bool: Whether to save the generated graphs to a file (optional).\n\nReturns\n\nfeasibility_graph, v_error_graph, o_error_graph, and time_graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#MPOPF.optimize_model-Tuple{MPOPF.AbstractMPOPFModel}","page":"API Reference","title":"MPOPF.optimize_model","text":"optimize_model(model::AbstractMPOPFModel)\n\nOptimize the given MPOPF model and print the optimal cost.\n\nnote: Note\nIf the model being optimized is of type MPOPFModelUncertainty then extra computation will be executed to determine if there are any unbalaced power at each bus for every scenario when consitering muplus and muminus.That is if sum_of_mu_plus and mu_minus are both > 0.01 at any given bus then an error message is printed.\n\nArguments\n\nmodel: The MPOPF model to optimize.\n\n\n\n\n\n","category":"method"},{"location":"api/#MPOPF.optimize_model_with_plot-Tuple{MPOPF.AbstractMPOPFModel}","page":"API Reference","title":"MPOPF.optimize_model_with_plot","text":"optimize_model_with_plot(model::AbstractMPOPFModel)\n\nOptimize the given MPOPF model, print the optimal cost,  and generate a PlotlyJS graph/plot of the optimization process.\n\nnote: Note\nif time_periods = 1 then the graph will represent the iterations taken by the solver otherwize the graph will represent each time period.\n\nArguments\n\nmodel: The MPOPF model to optimize and plot.\n\n\n\n\n\n","category":"method"},{"location":"api/#MPOPF.perform_feasibility","page":"API Reference","title":"MPOPF.perform_feasibility","text":"perform_feasibility(models::Array, finish_save::Bool=false)\n\nFields\n\nmodels::Array : a vector of 5, where each element is a model to be performed\n\n- 1 = AC, 2 = DC, 3 = Lin1, 4 = Lin2, 5 = Lin3\n- toggle 1 = on, 0 = off\n\nfinish_save::Bool=false : a boolean to determine if the graphs should be saved\n\nDescription\n\nThis function allows the user to execute feasibility tests on the different models provided\n\n- AC\n- DC\n- Lin1\n- Lin2\n- Lin3\n\nfor each case in the cases folder the function will loop over them and perform the feasibility tests\n\nfor each model that has been toggled to be on\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"feasibility/","page":"Feasibility of Linearization Techniques","title":"Feasibility of Linearization Techniques","text":"danger: Danger\nShould fill this in :)","category":"page"},{"location":"feasibility/#Feasibility-of-Linearization-Techniques","page":"Feasibility of Linearization Techniques","title":"Feasibility of Linearization Techniques","text":"","category":"section"},{"location":"feasibility/","page":"Feasibility of Linearization Techniques","title":"Feasibility of Linearization Techniques","text":"","category":"page"},{"location":"implementation_details/#Implementation-Details","page":"Implementation Details","title":"Implementation Details","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Here we will discuss how the project was built from a programming perspective.","category":"page"},{"location":"implementation_details/#Factory-Structs","page":"Implementation Details","title":"Factory Structs","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The Factories are used as parameters so that Julia's multiple dispatch feature runs the correct functions depending on the factory given.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"We have two, ACMPOPFModelFactory and DCMPOPFModelFactory which are subtypes of the abstract type AbstractMPOPFModelFactory. This abstract type is what the implementation functions expect but since AC and DC are subtypes they will work. This makes it possible to create functions with the same names that preform different operations depending on the factory provided.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Here is the code for our Factory Structs:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"# Abstract type as a base so that we can use this type as a parameter in fucntions\nabstract type AbstractMPOPFModelFactory end\n\n# This struct \"inherits\" from PowerFlowModelFactory\nmutable struct ACMPOPFModelFactory <: AbstractMPOPFModelFactory\n\tfile_path::String\n\toptimizer::Type\n\n\tfunction ACMPOPFModelFactory(file_path::String, optimizer::Type)\n\t\treturn new(file_path, optimizer)\n\tend\nend\n\n# This struct \"inherits\" from PowerFlowModelFactory\nmutable struct DCMPOPFModelFactory <: AbstractMPOPFModelFactory\n\tfile_path::String\n\toptimizer::Type\n\n\tfunction DCMPOPFModelFactory(file_path::String, optimizer::Type)\n\t\treturn new(file_path, optimizer)\n\tend\nend","category":"page"},{"location":"implementation_details/#MPOPF-Model-Structs","page":"Implementation Details","title":"MPOPF Model Structs","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The MPOPF Model objects are what the create_model function returns. They have all the information specific to MPOPF.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Similarly to our factory structs we currently have two concrete structs of MPOPF, MPOPFModel and MPOPFModelUncertainty which are subtypes of the abstract type AbstractMPOPFModel. This is useful when we want both MPOPF models to be passed in a function interchangeably (That is the case for the optimize_model function).","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"MPOPFModel has the following as variables: ","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Jump Model\nData read from file\ntime periods\nLoad Factors\nRamping Cost","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"MPOPFModelUncertainty has the same variables except that it holds one more variable scenarios which is only relevant for Uncertainty.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Here is the code for out MPOPF Model Structs:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"# Abstract type as a base so that we can use this type as a parameter in fucntions\nabstract type AbstractMPOPFModel end\n\n# The actual PowerFlowModel struct that \"inherits\" forrm AbstractPowerFlowModel\nmutable struct MPOPFModel <: AbstractMPOPFModel\n\tmodel::JuMP.Model\n\tdata::Dict\n\ttime_periods::Int64\n\tfactors::Vector{Float64}\n\tramping_cost::Int64\n\n\tfunction MPOPFModel(model::JuMP.Model, data::Dict, time_periods::Int64=1, factors::Vector{Float64}=[1.0], ramping_cost::Int64=0)\n\t\treturn new(model, data, time_periods, factors, ramping_cost)\n\tend\nend\n\n# Similar PowerFlowModel object but with an additional scenrios variable for uncertainty\nmutable struct MPOPFModelUncertainty <: AbstractMPOPFModel\n\tmodel::JuMP.Model\n\tdata::Dict\n\tscenarios::Dict\n\ttime_periods::Int64\n\tfactors::Vector{Float64}\n\tramping_cost::Int64\n\n\tfunction MPOPFModelUncertainty(model::JuMP.Model, data::Dict, scenarios::Dict, time_periods::Int64=1, factors::Vector{Float64}=[1.0], ramping_cost::Int64=0)\n\t\treturn new(model, data, scenarios, time_periods, factors, ramping_cost)\n\tend\nend","category":"page"},{"location":"implementation_details/#Create-Model-Functions","page":"Implementation Details","title":"Create Model Functions","text":"","category":"section"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"At the moment we have two create_model functions. The first returns an MPOPFModel object and the second returns an MPOPFModelUncertainty object. The system knows which one to call depending on whether the scenarios variable was given.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Both share the same logic so whatever I explain about the first can be extrapolated to the second.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The create_model function takes in a factory of type AbstractMPOPFModelFactory as the first parameter. This means that both ACMPOPFModelFactory, DCMPOPFModelFactory, or any other Factory that inherits from the Abstract one is accepted. The following three parameters, time_periods, factors, and ramping_cost are only relevant for multiperiod so they are optional. (If not provided, the system will assume one period).","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"For AC and DC models, the steps of creating a model are the same. We first define the model variables, then we define the model objective function, and lastly we set the model constraints.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"However, inside of these functions different things happen depending if we want AC, DC, or any other form of defining. This is why the factory is passed as a parameter inside the set_model_variables!, set_model_objective_function!, and set_model_constraints! functions.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Thanks to Julia's multiple dispatch feature, the correct function will be called depending on the type of the factory. Therefore, the correct variables, objective function, and constraints will be added without having to create massive if statements that check what model we want.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Here is our create model function:","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"function create_model(factory::AbstractMPOPFModelFactory; time_periods::Int64=1, factors::Vector{Float64}=[1.0], ramping_cost::Int64=0, model_type=undef)::MPOPFModel\n    data = PowerModels.parse_file(factory.file_path)\n    PowerModels.standardize_cost_terms!(data, order=2)\n    PowerModels.calc_thermal_limits!(data)\n\n    model = JuMP.Model(factory.optimizer)\n\n    power_flow_model = MPOPFModel(model, data, time_periods, factors, ramping_cost)\n\n    set_model_variables!(power_flow_model, factory)\n    set_model_objective_function!(power_flow_model, factory)\n    model_type !== undef ? set_model_constraints!(power_flow_model, factory, model_type) : set_model_constraints!(power_flow_model, factory)\n\n    return power_flow_model\nend","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"note: Note\nThe model_type variable is only relevant for approximation techniques and will be discussed here: Approximation Techniques for MPOPF","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"Here is an example of the AC and DC set_model_variables! functions. Take note of the factory type accepted.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"AC","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"function set_model_variables!(power_flow_model::AbstractMPOPFModel, factory::ACMPOPFModelFactory)\n# Here would be the code for AC model\n# Take note of the second parameter which accepts type ACMPOPFModelFactory\nend","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"DC","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"function set_model_variables!(power_flow_model::AbstractMPOPFModel, factory::DCMPOPFModelFactory)\n# Here would be the code for DC model\n# Take note of the second parameter which accepts type DCMPOPFModelFactory\nend","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"The factory is not used for any computation, it is just there to let the system know which function should be called in what situation.","category":"page"},{"location":"implementation_details/","page":"Implementation Details","title":"Implementation Details","text":"","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In these following sections we will describe how to get started with using our code.","category":"page"},{"location":"getting_started/#Before-we-Begin","page":"Getting Started","title":"Before we Begin","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To run the scripts, you need to have the following Julia packages installed:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"JuMP\nPowerModels\nIpopt\nGurobi\nPlotlyJS (Optionally for creating visualizations)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can install these packages using the Julia package manager:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"JuMP\")\nPkg.add(\"PowerModels\")\nPkg.add(\"Ipopt\")\nPkg.add(\"Gurobi\")\nPkg.add(\"PlotlyJS\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To be able to Create MPOPF Models we will need to clone the GitHub repository:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"git clone _________________________________________ FILL THIS IN","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Then install the MPOPF package using Julia's Package Manager:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"MPOPF\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The packages mentioned above will be installed automatically as they are dependencies.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nOptionally if we don't want to install the MPOPF Package we can run the file locally. (Note: The period indicates that it is a local Module) This can be done with the following three lines of code.using JuMP, PowerModels, Ipopt, Gurobi, PlotlyJS\ninclude(\"MPOPF.jl\")\nusing .MPOPFThis method is not recommended, simpler to go with the first.","category":"page"},{"location":"getting_started/#What-to-Include-in-your-Workspace","page":"Getting Started","title":"What to Include in your Workspace","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now to actually use the MPOPF package we simply include it in the workspace along with it's dependencies","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using PowerModels, JuMP, Ipopt, Gurobi, PlotlyJS\nusing MPOPF","category":"page"},{"location":"getting_started/#Basic-Example","page":"Getting Started","title":"Basic Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here is a simple example to showcase how a model can be created and optimized:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using PowerModels, JuMP, Ipopt, Gurobi, PlotlyJS\nusing MPOPF\n\n# We define the file path of the case we want to solve\nfile_path = \"Cases/case14.m\"\n\n# To create a DC model we need to first define a DC factory\n# It is done with the following function\n# Takes in two parameters, the fille path for the case we want to solve\n# and the optimizer we want to use, Ipopt or Gurobi\ndc_factory = DCMPOPFModelFactory(file_path, Ipopt.Optimizer)\n\n# After creating our factory we pass it to our create model function\nmy_dc_model = create_model(dc_factory)\n\n# Once we have our model we just optimize\n# This will print the Minimum Cost\noptimize_model(my_dc_model)\n\n# If we want to make an AC model instead simply create it with an AC Factory\nac_factory = ACMPOPFModelFactory(file_path, Ipopt.Optimizer)\nmy_ac_model = create_model(ac_factory)\noptimize_model(my_ac_model)","category":"page"},{"location":"getting_started/#Multi-Period-Example","page":"Getting Started","title":"Multi-Period Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To create a model with multiple periods we just specify the number of periods, the factors for the loads (multiplied to the current load to create different demand for the next period), and the ramping cost. They are specified in the create_model function","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using PowerModels, JuMP, Ipopt, Gurobi, PlotlyJS\nusing MPOPF\n\n# We define the file path of the case we want to solve\nfile_path = \"./Cases/case14.m\"\n\n# Our DC factory\ndc_factory = DCMPOPFModelFactory(file_path, Ipopt.Optimizer)\n\n# Create the model as before but now with multiperiod variables specified\n# Time Periods = 3\n# One factor per time period\n# Ramping Cost = 7\nmy_dc_model = create_model(dc_factory; time_periods=3, factors=[1.0, 0.98, 1.03], ramping_cost=7)\n\n# Once we have our model we just optimize\n# This will print the Minimum Cost\noptimize_model(my_dc_model)","category":"page"},{"location":"getting_started/#Further-Reading","page":"Getting Started","title":"Further Reading","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Curious about the implementation of this project? Visit the Implementation Details page.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"approximation/","page":"Approximation Techniques","title":"Approximation Techniques","text":"danger: Danger\nShould fill this in :)","category":"page"},{"location":"approximation/#Approximation-Techniques-for-MPOPF","page":"Approximation Techniques","title":"Approximation Techniques for MPOPF","text":"","category":"section"},{"location":"approximation/","page":"Approximation Techniques","title":"Approximation Techniques","text":"Currently this is a simple example showcasing how code can be run and a dynamic graph can be displayed on the docs.","category":"page"},{"location":"approximation/","page":"Approximation Techniques","title":"Approximation Techniques","text":"using JuMP, Ipopt\nusing MPOPF\nusing PlotlyDocumenter\n\nfile_path = \"./Cases/case14.m\"\n\n# We haev 24 values for 24 time periods\ndemand_factors = [1.0, 1.05, 0.98, 1.03, 0.96, 0.97, 0.99, 1.0, 1.05, 1.03, 1.01, 0.95, 1.04, 1.02, 0.99, 0.99, 0.99, 0.95, 1.04, 1.02, 0.98, 1.0, 1.02, 0.97]\n\nmy_ac_factory = ACMPOPFModelFactory(file_path, Ipopt.Optimizer)\nmy_ac_model = create_model(my_ac_factory; time_periods=24, factors=demand_factors, ramping_cost=2000)\n\ngraph = optimize_model_with_plot(my_ac_model)\n\nto_documenter(graph.plot)","category":"page"},{"location":"approximation/","page":"Approximation Techniques","title":"Approximation Techniques","text":"This is a simple example showcasing how code can be run and a dynamic graph can be displayed on the docs.","category":"page"},{"location":"approximation/","page":"Approximation Techniques","title":"Approximation Techniques","text":"","category":"page"},{"location":"future_development/#Future-Development","page":"Future Development","title":"Future Development","text":"","category":"section"},{"location":"future_development/","page":"Future Development","title":"Future Development","text":"To further improve the project and add more functionality to the system, there are two good things that can be done.","category":"page"},{"location":"future_development/#Similar-Procedure-as-AC-or-DC","page":"Future Development","title":"Similar Procedure as AC or DC","text":"","category":"section"},{"location":"future_development/","page":"Future Development","title":"Future Development","text":"If the functionality that we want to add follows the same procedure for creating a model that AC or DC follow then we can follow these steps:","category":"page"},{"location":"future_development/","page":"Future Development","title":"Future Development","text":"Create a new MPOPFModelFactory that \"inherits\" from AbstractMPOPFModelFactory. At the simplest case this can be identical to AC or DC factories with the name changed.\nCreate your new model functionality by implementing these three functions: set_model_variables!, set_model_objective_function!, and set_model_constraints!. Note that the factory passed to these functions should be your newly created factory.\nThat's it, now you can create a model with your new implementation with the create_model function and your factory passed to it.","category":"page"},{"location":"future_development/#Different-Procedure-as-AC-or-DC","page":"Future Development","title":"Different Procedure as AC or DC","text":"","category":"section"},{"location":"future_development/","page":"Future Development","title":"Future Development","text":"If the new functionality that we want to add does not follow the same steps then a little more work needs to be done. ","category":"page"},{"location":"future_development/","page":"Future Development","title":"Future Development","text":"Let's take uncertainty for example. Uncertainty should work for both AC and DC, it needs a new variable to handle scenarios and it modifies current constraints instead of adding on to them. Here are the steps I took to create it. Similar process can be taken for something new.","category":"page"},{"location":"future_development/","page":"Future Development","title":"Future Development","text":"Since we need a new variable I created a new struct MPOPFModelUncertainty which is identical to MPOPFModel but with a new variable scenarios. It is also a subtype of AbstractMPOPFModel.\nI then created a new create_model function that accepts this new variable scenarios as a parameter and returns a model of type MPOPFModelUncertainty. (The system will know which create model function to call depending on if the scenarios variable is provided).\nI implemented the process for uncertainty inside this new create_model function.","category":"page"},{"location":"future_development/","page":"Future Development","title":"Future Development","text":"","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"danger: Danger\nMust Complete This :)","category":"page"},{"location":"background/#Background-Information-for-OPF-(Optimal-Power-Flow)","page":"Background","title":"Background Information for OPF (Optimal Power Flow)","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"This project works with a network and numerically analyses the flow of electric power through it. The goal is to find a way to optimize the system in a way that is effective and can be used in large networks. It is built upon IPOPT and GUROBI optimization models, using Julia and JuMP to carry out the optimization. Using these resources our code aims to explore the various constraints and functions to help us solve Multi Period Optimal Power Flow (MPOPF), or even introduce a better way of finding solutions that are more effective and useful than the current ones. These are initially tested using cases from Matpower and using Power Models, a Julia/JuMP package for Steady-State Power Network Optimization.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Using these optimized models, we attempt to come with a value to set the generators to, that produce enough power for consumer use, but also not so much that there is a lot of waste. If there is not enough power produced initially, changing the generator to produce more takes time and energy, introducing an additional cost. It can also cause a blackout if the demand is too high and cannot be produced. This is the primary reason for this project. ","category":"page"},{"location":"background/#Introduction","page":"Background","title":"Introduction","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"First the importance of this project and some basic details are given, then we go into what AC and DC are, and some additional details about Power Flow, such as the transition to MPOPF and the variables to consider. Next, we talk about how to access information from the case file and how to use the dictionary. Then we move on to what we are currently working on, a little intro into the different areas of work and some things to note when working on this project. ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"add Sajad's pdf, link to the textbook, and the blog about power flow as well where to find variable.","category":"page"},{"location":"background/#Basics-and-Key-Terms","page":"Background","title":"Basics and Key Terms","text":"","category":"section"},{"location":"background/#AC-and-DC","page":"Background","title":"AC and DC","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Most real world applications of power use Alternating Current (AC). This is where the direction of the current changes periodically. This is used becasue it is less expensive and easier to generate than Direct Current (DC). Comparitively, AC can be transmitted across longer distances with less energy loss. This change in direction introduces more variables into the equation we use to calculate it, such variablity in theta and voltage magnitude. AC is made up of both active and reactive power. Active power is usable or consumed electrical energy which reactive power is the part that is introduced due to the alternating current. Reactive power is imaginary, also known as wattless power, and is calculated in Volt-Amperes Reactive (VAR). Due to the calculations necessary for optimizing an AC solution, it cannot be used for large networks, however we can use it on test cases to check feasibilty of solutions using a model that linearly approximates the equation.","category":"page"},{"location":"background/#Types-of-Buses","page":"Background","title":"Types of Buses","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"There are Pq buses, Pv buses and slack/reference buses. A pq (load) bus has active and reactive power specified (p and q) but voltage and load angle are variable. A pv (generator) bus have active power and voltage specified, while reactive power and load angle are variable, and a slack bus has voltage and load angle specified but the active and reactive power are variable.","category":"page"},{"location":"background/#Terms-and-Variables","page":"Background","title":"Terms and Variables","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Which terms and which variable and formulas?\nCost, ramping, etc.","category":"page"},{"location":"background/#Additional-Resources","page":"Background","title":"Additional Resources","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"link to notebook for DC code to look over","category":"page"},{"location":"background/#References","page":"Background","title":"References","text":"","category":"section"},{"location":"background/#How-to-work-with-the-case-files","page":"Background","title":"How to work with the case files","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"You can use the examples given in the code that already exists in both the src and the archive folders, as well as the notebook linked above. ","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The data from the case file is stored and access through dictionary. This is similar to the usage of maps in languages such as Java and C++. Essentially there is a key that is associated with a value. Below is a simple example of dictionary.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"# Creating a dictionary\nmy_dict = Dict(\"key1\" => \"value1\", \"key2\" => \"value2\", \"key3\" => \"value3\")\n\n# Accessing values using keys\nprintln(my_dict[\"key1\"])  # Output: value1\n","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"The variable is set when the file is parsed. Such as, in case5-main.jl in the archive directory, you can see that data = parseFile(file_path). Next we have the line ref = PowerModels.build_ref(data)[:it][:pm][:nw][0]. Here PowerModels.build_ref(data) is the dictionary, each thing specifies what you want to extract, :it refers to iteratively extracting the data, similarly :pm is for the power model data, :nw is for the network data and then :0 tells it to start at index 0. Essentially ref is a cleaned-up and indexed version of data.","category":"page"},{"location":"background/","page":"Background","title":"Background","text":"Further down, you can extract variables based on this. Such as ref[:bus] for bus data and ref[:gen] for generator data and so on.","category":"page"},{"location":"background/#Current-Code","page":"Background","title":"Current Code","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Currently we have a refactored version of the code that is easy to modify. It is in the src folder, and made following design pattern and OOD principles, such as abstraction, SOLID + DRY and so on. You can find detailed information about this as well as how to use it in the README file and in the CodeBaseDocumentation.pdf.","category":"page"},{"location":"background/#Areas-of-current-work","page":"Background","title":"Areas of current work","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"As mentioned above, AC, used real world application, uses many different non-linear variables which can be easily calculated and optimized at a small scale but cannot be done with large networks. Instead, we use a type of linear approximation. Currently most uses in industry are built upon using Direct Current, or DC, models. We are looking into a different linear approximation that may be more accurate given the way AC works, and the losses associated with it. We are also looking into the uncertainty that is introduced between predictions and actual results and attempting to account for and minimize those differences over multiple time periods. Another area of work in this particular project is local search. Which calculates a local minimum and then compares it to a larger area to see if there is yet a better value. ","category":"page"},{"location":"background/#Approximation","page":"Background","title":"Approximation","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"Currently still trying to figure out certain assumptions made in the equations written in the appendix.","category":"page"},{"location":"background/#Uncertainty","page":"Background","title":"Uncertainty","text":"","category":"section"},{"location":"background/#Local-Search","page":"Background","title":"Local Search","text":"","category":"section"},{"location":"background/#Feasibility-Check","page":"Background","title":"Feasibility Check","text":"","category":"section"},{"location":"background/#To-Note","page":"Background","title":"To Note","text":"","category":"section"},{"location":"background/#References-2","page":"Background","title":"References","text":"","category":"section"},{"location":"background/","page":"Background","title":"Background","text":"","category":"page"},{"location":"class_diagram/","page":"Class Diagram","title":"Class Diagram","text":"danger: Danger\nStill Working on this :(","category":"page"},{"location":"class_diagram/#Class-UML-Diagram","page":"Class Diagram","title":"Class UML Diagram","text":"","category":"section"},{"location":"class_diagram/","page":"Class Diagram","title":"Class Diagram","text":"classDiagram\n         AbstractMPOPFModelFactory <|-- ACMPOPFModelFactory\n         AbstractMPOPFModelFactory <|-- DCMPOPFModelFactory\n   \n         AbstractMPOPFModel <|-- MPOPFModel\n         AbstractMPOPFModel <|-- MPOPFModelUncertainty\n   \n         AbstractMPOPFModelFactory : +create_model(factory AbstractMPOPFModelFactory, time_periods Int64, factors Vector~Float64~, ramping_cost Int64) MPOPFModel\n         AbstractMPOPFModelFactory : +create_model(factory AbstractMPOPFModelFactory, scenarios Dict, time_periods Int64, factors Vector~Float64~, ramping_cost Int64) MPOPFModelUncertainty\n         AbstractMPOPFModel : +optimize_model(model AbstractMPOPFModel)\n   \n         ACMPOPFModelFactory : +file_path String\n         ACMPOPFModelFactory : +optimizer Type\n         ACMPOPFModelFactory : +ACMPOPFModelFactory(file_path, optimizer)\n   \n         DCMPOPFModelFactory : +file_path String\n         DCMPOPFModelFactory : +optimizer Type\n         DCMPOPFModelFactory : +DCMPOPFModelFactory(file_path, optimizer)\n   \n         MPOPFModel : +model JuMP.Model\n         MPOPFModel : +data Dict\n         MPOPFModel : +time_periods Int64\n         MPOPFModel : +factors Vector~Float64~\n         MPOPFModel : +ramping_cost Int64\n         MPOPFModel : +MPOPFModel(model, data, time_periods, factors, ramping_cost)\n   \n         MPOPFModelUncertainty : +model JuMP.Model\n         MPOPFModelUncertainty : +data Dict\n         MPOPFModelUncertainty : +scenarios Dict\n         MPOPFModelUncertainty : +time_periods Int64\n         MPOPFModelUncertainty : +factors Vector~Float64~\n         MPOPFModelUncertainty : +ramping_cost Int64\n         MPOPFModelUncertainty : +MPOPFModelUncertainty(model, data, scenarios, time_periods, factors, ramping cost)\n   \n         %% Operations\n         class Operations {\n           <<interface>>\n           +set_model_variables!(AbstractMPOPFModel, AbstractMPOPFModelFactory)\n           +set_model_objective_function!(AbstractMPOPFModel, AbstractMPOPFModelFactory)\n           +set_model_constraints!(AbstractMPOPFModel, AbstractMPOPFModelFactory)\n           +set_model_uncertainty_variables!(MPOPFModelUncertainty)\n           +set_model_uncertainty_objective_function!(MPOPFModelUncertainty, AbstractMPOPFModelFactory)\n           +set_model_uncertainty_constraints!(MPOPFModelUncertainty, AbstractMPOPFModelFactory)\n         }\n         AbstractMPOPFModelFactory --> Operations\n         MPOPFModel --> Operations\n         MPOPFModelUncertainty --> Operations","category":"page"},{"location":"class_diagram/","page":"Class Diagram","title":"Class Diagram","text":"","category":"page"},{"location":"design_philosophy/#Design-Philosophy","page":"Design Philosophy","title":"Design Philosophy","text":"","category":"section"},{"location":"design_philosophy/","page":"Design Philosophy","title":"Design Philosophy","text":"The design of this project is grounded in several key principles aimed at ensuring flexibility, modularity, and ease of use. These principles guide the structure and development of the codebase, making it robust and adaptable to future development.","category":"page"},{"location":"design_philosophy/#1.-Modularity","page":"Design Philosophy","title":"1. Modularity","text":"","category":"section"},{"location":"design_philosophy/","page":"Design Philosophy","title":"Design Philosophy","text":"The codebase is designed with modularity in mind. By defining abstract types and leveraging Julia's multiple dispatch feature, we allow for the seamless addition of new model types and functionalities. Each component, whether it be AC, DC, or uncertainty models, can be developed and maintained independently. This modular approach ensures that changes in one part of the system do not inadvertently impact others.","category":"page"},{"location":"design_philosophy/#2.-Separation-of-Concerns","page":"Design Philosophy","title":"2. Separation of Concerns","text":"","category":"section"},{"location":"design_philosophy/","page":"Design Philosophy","title":"Design Philosophy","text":"The design follows the principle of separation of concerns, where each part of the system has a distinct responsibility. For instance, the factories are responsible for creating models, while the models themselves encapsulate the specific optimization logic. This separation helps in isolating and addressing issues, testing components independently, and ensuring that each part of the system can evolve without causing disruptions.","category":"page"},{"location":"design_philosophy/#3.-Reusability","page":"Design Philosophy","title":"3. Reusability","text":"","category":"section"},{"location":"design_philosophy/","page":"Design Philosophy","title":"Design Philosophy","text":"Reusability is emphasized through the use of common abstract interfaces and the implementation of general functions that can operate on any subtype. For example, the optimize_model function can be used with any model that conforms to the AbstractMPOPFModel interface.","category":"page"},{"location":"design_philosophy/","page":"Design Philosophy","title":"Design Philosophy","text":"","category":"page"},{"location":"#Multiperiod-Optimal-Power-Flow-(MPOPF)","page":"Home","title":"Multiperiod Optimal Power Flow (MPOPF)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for the MPOPF project. This Julia package provides tools for analyzing and optimizing power flow in electrical networks over multiple time periods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nIf you are unsure about power flow concepts, please read through the background page. It will go over the background on this project such AC and DC Power Flow caluclations as well as different approximation formulas used. Additionally, Key terms and variabels along with additional resources for further reading will be provided there.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Support for AC and DC power flow models\nMulti-period optimization\nUncertainty modeling\nApproximation techniques\nLocal search optimization\nFeasibility checking","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"class_diagram.md\", \"getting_started.md\", \"background.md\", \"implementation_details.md\", \"approximation.md\", \"feasibility.md\", \"future_development.md\", \"design_philosophy.md\", \"api.md\"]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
